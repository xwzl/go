在对Go语言的类型系统做了全面的讲解后，本节对函数类型进行全面深入的介绍。首先介绍“有名函数”和“匿名函数”两个概念。使用 func FunctionName() 语法格式定义的函数我们称为“有名函数”，这里所谓的有名是指函数在定义时指定了“函数名”；与之对应的是“匿名函数”，所谓的匿名函数就是在定义时使用 func() 语法格式，没有指定函数名。通常所说的函数就是指“有名函数”。

函数类型也分两种，一种是函数字面量类型（未命名类型），另一种是函数命名类型。

# 函数字面量类型

函数字面量类型的语法表达格式是 func(InputTypeList)OutputTypeList，可以看出“有名函数”和“匿名函数”的类型都属于函数字面量类型。有名函数的定义相当于初始化一个函数字面量类型后将其赋值给一个函数名变量：“匿名函数”的定义也是直接初始化一个函数字面量类型，只是没有绑定到一个具体变量上。从 Go 类型系统的角度来看，“有名函数”和“匿名函数”都是函数字面量类型的实例。

### 函数命名类型

从前面章节知道可以使用 type NewType OldType 语法定义一种新类型，这种类型都是命名类型，同理可以使用该方法定义一种新类型：函数命名类型，简称函数类型。例如：
type NewFuncType FuncLiteral

依据Go语言类型系统的概念，NewFuncType 为新定义的函数命名类型，FuncLiteral 为函数字面量类型，FuncLiteral 为函数类型 NewFune Type 的底层类型。当然也可以使用 type 在一个函数类型中再定义一个新的函数类型，这种用法在语法上是允许的，但很少这么使用。例如：
type NewFuncType OldFuncType

### 函数签名

有了上面的基础，函数签名就比较好理解了，所谓“函数签名”就是“有名函数”或“匿名函数”的字面量类型。所以有名函数和匿名函数的函数签名可以相同，函数签名是函数的“字面量类型”，不包括函数名。

### 函数声明
Go语言没有C语言中函数声明的语义，准确地说，Go 代码调用 Go 编写的函数不需要声明，可以直接调用，但 Go 调用汇编语言编写的函数还是要使用函数声明语句，示例如下。

```
//函数声明＝函数名＋函数签名
//函数签名
func (InputTypeList)OutputTypeList
//函数声明
func FuncName (InputTypeList)OutputTypeList
```

下面通过一个具体的示例来说明上述概念。

```
//有名函数定义，函数名是add
//add 类型是函数字面宣类型 func(int, int) int
func add(a, b int) int {
    return a+b
}
//函数声明语句，用于 Go 代码调用汇编代码
func add(int, int) int
//add 函数的签名，实际上就是 add 的字面量类型
func (int, int) int
//匿名函数不能独立存在，常作为函数参数、返回值，或者赋值给某个变量
//匿名函数可以直接显式初始化
//匿名函数的类型也是函数字面量类型 func (int, int) int
func (a,b int) int {
    return a+b
}
//新定义函数类型ADD
//ADD 底层类型是函数字面量类型 func (int, int) int
type ADD func (int, int) int
//add 和 ADD 的底层类型相同，并且 add 是字面量类型
//所以 add 可直接赋值给 ADD 类型的变量 g
var g ADD = add
func main() {
    f := func(a, b int) int {
        return a + b
    }
    g(1, 2)
    f(1, 2)
    //f 和 add 的函数签名相同
    fmt.Printf("%T\n", f)   // func(int, int) int
    fmt.Printf("%T\n", add) // func(int, int) int
}
```
前面谈到字面量类型是一种未命名类型 (unnamed type)，其不能定义自己的方法，所以必须显式地使用 type 声明一个有名函数类型，然后为其添加方法。通常说的函数类型就是指有名函数类型，“函数签名”是指函数的字面量类型，在很多地方把函数类型和函数签名等价使用，这是不严谨的。

由类型转换的规则可知：这两种类型的底层类型相同，并且其中一个是字面量类型，二者是可以相互转换的。下面来看一下经典的 http 标准库对函数类型的实现，进一步理解这种用法。

```
//src/net/http/server.go
//定义一个有名函数类型 HandlerFune
type HandlerFunc func(ResponseWriter, *Request)
//为有名的函数类型添加方法
//这是一种包装器的编程技法
//ServeHTTP calls f(w, r).
func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {
    f(w, r)
}
//函数类型 HandlerFunc 实现了接口 Handler 的方法
type Handler interface {
    ServeHTTP(ResponseWriter, *Request)
}
func (mux *ServeMux) Handle(pattern string, handler Handler)
//所以 HandlerFunc 类型的交量可以传递给 Handler 接口变量
func (mux *ServeMux) HandleFune (pattern string, handler func (ResponseWriter,
*Request)) {
    mux.Handle(pattern, HandlerFunc(handler))
}
```
通过 http 标准库里面对于函数类型的使用，我们可以看到函数类型的如下意义：

- 函数也是一种类型，可以在函数字面量类型的基础上定义一种命名函数类型。
- 有名函数和匿名函数的函数签名与命名函数类型的底层类型相同，它们之间可以进行类型转换。
- 可以为有名函数类型添加方法，这种为一个函数类型添加方法的技法非常有价值，可以方便地为一个函数增加“拦截”或“过滤”等额外功能，这提供了一种装饰设计模式。
- 为有名函数类型添加方法，使其与接口打通关系，使用接口的地方可以传递函数类型的变量，这为函数到接口的转换开启了大门。

函数构成代码执行的逻辑结构。在Go语言中，函数的基本组成为：关键字func、函数名、参数列表、返回值、函数体和返回语句。

每一个程序都包含很多的函数：函数是基本的代码块。

因为Go语言是编译型语言，所以函数编写的顺序是无关紧要的；鉴于可读性的需求，最好把 main() 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。

编写多个函数的主要目的是将一个需要很多行代码的复杂问题分解为一系列简单的任务（那就是函数）来解决。而且，同一个任务（函数）可以被调用多次，有助于代码重用。（事实上，好的程序是非常注意 DRY 原则的，即不要重复你自己（Don't Repeat Yourself），意思是执行特定任务的代码只能在程序里面出现一次。）

当函数执行到代码块最后一行（} 之前）或者 return 语句的时候会退出，其中 return 语句可以带有零个或多个参数；这些参数将作为返回值供调用者使用。简单的 return 语句也可以用来结束 for 死循环，或者结束一个协程（goroutine）。

Go语言里面拥三种类型的函数：

- 普通的带有名字的函数
- 匿名函数或者 lambda 函数
- 方法

### 普通函数声明（定义）

函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。

    func 函数名(形式参数列表)(返回值列表){
        函数体
    }

形式参数列表描述了函数的参数名以及参数类型。这些参数作为局部变量，其值由参数调用者提供。返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。

如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。 在下面的 hypot 函数中：

    func hypot(x, y float64) float64 {
        return math.Sqrt(x*x + y*y)
    }
    fmt.Println(hypot(3,4)) // "5"
    
x 和 y 是形参名，3 和 4 是调用时的传入的实数，函数返回了一个 float64 类型的值。返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为 0。

如果一个函数在声明时，包含返回值列表，该函数必须以 return 语句结尾，除非函数明显无法运行到结尾处。例如函数在结尾时调用了 panic 异常或函数中存在无限循环。

正如 hypot 函数一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面 2 个声明是等价的：

    func f(i, j, k int, s, t string) { /* ... */ }
    func f(i int, j int, k int, s string, t string) { /* ... */ }

下面，我们给出 4 种方法声明拥有 2 个 int 型参数和 1 个 int 型返回值的函数，空白标识符 _ 可以强调某个参数未被使用。

    func add(x int, y int) int {return x + y}
    func sub(x, y int) (z int) { z = x - y; return}
    func first(x int, _ int) int { return x }
    func zero(int, int) int { return 0 }
    fmt.Printf("%T\n", add) // "func(int, int) int"
    fmt.Printf("%T\n", sub) // "func(int, int) int"
    fmt.Printf("%T\n", first) // "func(int, int) int"
    fmt.Printf("%T\n", zero) // "func(int, int) int"
    
函数的类型被称为函数的标识符。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型和标识符。形参和返回值的变量名不影响函数标识符也不影响它们是否可以以省略参数类型的形式表示。

每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。

在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。**函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。实参通过值的方式传递，因此函数的形参是实参的拷贝**。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针、slice(切片)、map、function、channel等类型，实参可能会由于函数的简介引用被修改。

### 函数的返回值

Go语言支持多返回值，多返回值能方便地获得函数执行后的多个返回参数，Go语言经常使用多返回值中的最后一个返回参数返回函数执行中可能发生的错误。示例代码如下：

    conn, err := connectToNetwork()

在这段代码中，connectToNetwork 返回两个参数，conn 表示连接对象，err 返回错误。

#### 其它编程语言中函数的返回值

- C/C++ 语言中只支持一个返回值，在需要返回多个数值时，则需要使用结构体返回结果，或者在参数中使用指针变量，然后在函数内部修改外部传入的变量值，实现返回计算结果。C++ 语言中为了安全性，建议在参数返回数据时使用“引用”替代指针。
- C# 语言也没有多返回值特性。C# 语言后期加入的 ref 和 out 关键字能够通过函数的调用参数获得函数体中修改的数据。
- lua 语言没有指针，但支持多返回值，在大块数据使用时方便很多。

Go语言既支持安全指针，也支持多返回值，因此在使用函数进行逻辑编写时更为方便。

#### 同一种类型返回值

如果返回值是同一种类型，则用括号将多个返回值类型括起来，用逗号分隔每个返回值的类型。

使用 return 语句返回时，值列表的顺序需要与函数声明的返回值类型一致。示例代码如下：

    func typedTwoValues() (int, int) {
        return 1, 2
    }
    func main() {
        a, b := typedTwoValues()
        fmt.Println(a, b)
    }
    
代码输出结果：
    1 2

纯类型的返回值对于代码可读性不是很友好，特别是在同类型的返回值出现时，无法区分每个返回参数的意义。
#### 带有变量名的返回值

Go语言支持对返回值进行命名，这样返回值就和参数一样拥有参数变量名和类型。

命名的返回值变量的默认值为类型的默认值，即数值为 0，字符串为空字符串，布尔为 false、指针为 nil 等。

下面代码中的函数拥有两个整型返回值，函数声明时将返回值命名为 a 和 b，因此可以在函数体中直接对函数返回值进行赋值。在命名的返回值方式的函数体中，在函数结束前需要显式地使用 return 语句进行返回，代码如下：
  
    func namedRetValues() (a, b int) {
        a = 1
        b = 2
        return
    }
    
代码说明如下：

- 第 1 行，对两个整型返回值进行命名，分别为 a 和 b。
- 第 3 行和第 4 行，命名返回值的变量与这个函数的布局变量的效果一致，可以对返回值进行赋值和值获取。
- 第 6 行，当函数使用命名返回值时，可以在 return 中不填写返回值列表，如果填写也是可行的。下面代码的执行效果和上面代码的效果一样。
    
    func namedRetValues() (a, b int) {
        a = 1
        return a, 2
    }
    
#### 提示

同一种类型返回值和命名返回值两种形式只能二选一，混用时将会发生编译错误，例如下面的代码：

    func namedRetValues() (a, b int, int)
    
编译报错提示：
    
    mixed named and unnamed function parameters

意思是：在函数参数中混合使用了命名和非命名参数。

### 调用函数

函数在定义后，可以通过调用的方式，让当前代码跳转到被调用的函数中进行执行。调用前的函数局部变量都会被保存起来不会丢失；被调用的函数结束后，恢复到被调用函数的下一行继续执行代码，之前的局部变量也能继续访问。

函数内的局部变量只能在函数体中使用，函数调用结束后，这些局部变量都会被释放并且失效。

Go语言的函数调用格式如下：
返回值变量列表 = 函数名(参数列表)

下面是对各个部分的说明：

- 函数名：需要调用的函数名。
- 参数列表：参数变量以逗号分隔，尾部无须以分号结尾。
- 返回值变量列表：多个返回值使用逗号分隔。

例如，加法函数调用样式如下：
    
    result := add(1,1)
    
### 参数传递

Go语言默认使用按值传递来传递参数，也就是传递参数的副本。函数接收参数副本之后，在使用变量的过程中可能对副本的值进行更改，但不会影响到原来的变量，比如 Function(arg1) 。

如果你希望函数可以直接修改参数的值，而不是对参数的副本进行操作，你需要将参数的地址（变量名前面添加 & 符号，比如 &variable）传递给函数，这就是按引用传递，比如 Function(&arg1) ，此时传递给函数的是一个指针。

如果传递给函数的是一个指针，指针的值（一个地址）会被复制，但指针的值所指向的地址上的值不会被复制；我们可以通过这个指针的值来修改这个值所指向的地址上的值。指针也是变量类型，有自己的地址和值，通常指针的值指向一个变量的地址。所以，按引用传递也是按值传递。

几乎在任何情况下，传递指针（一个 32 位或者 64 位的值）的消耗都比传递副本来得少。在函数调用时，像切片（slice）、字典（map）、接口（interface）、通道（channel）这样的引用类型都是默认使用引用传递（即使没有显示的指出指针）。

有些函数只是完成一个任务，并没有返回值。我们仅仅是利用了这种函数的副作用，就像输出文本到终端，发送一个邮件或者是记录一个错误等。

但是绝大部分的函数还是带有返回值的。

下面的示例中 MultiPly3Nums 函数带有三个形参，分别是 a 、b 、c ，还有一个 int 类型的返回值（被注释的代码具有和未注释部分同样的功能，只是多引入了一个本地变量）：

    package main
        
    import "fmt"
    
    func main() {
        fmt.Printf("Multiply 2 * 5 * 6 = %d\n", MultiPly3Nums(2, 5, 6))
        // var i1 int = MultiPly3Nums(2, 5, 6)
        // fmt.Printf("MultiPly 2 * 5 * 6 = %d\n", i1)
    }
    
    func MultiPly3Nums(a int, b int, c int) int {
        // var product int = a * b * c
        // return product
        return a * b * c
    }
    
输出显示：

    Multiply 2 * 5 * 6 = 60

如果一个函数需要返回四到五个值，我们可以传递一个切片给函数（如果返回值具有相同类型）或者是传递一个结构体（如果返回值具有不同的类型）。因为传递一个指针允许直接修改变量的值，消耗也更少。